{"version":3,"file":"js-joda.esm.js","sources":["../src/errors.js","../src/assert.js","../src/MathUtil.js","../src/Enum.js","../src/temporal/TemporalAmount.js","../src/temporal/TemporalUnit.js","../src/Duration.js","../src/YearConstants.js","../src/temporal/ChronoUnit.js","../src/temporal/TemporalField.js","../src/temporal/ValueRange.js","../src/temporal/ChronoField.js","../src/temporal/TemporalQueries.js","../src/temporal/TemporalAccessor.js","../src/temporal/TemporalQuery.js","../src/DayOfWeek.js","../src/Month.js","../src/Period.js","../src/format/ParsePosition.js","../src/format/EnumMap.js","../src/format/ResolverStyle.js","../src/temporal/Temporal.js","../src/chrono/ChronoLocalDate.js","../src/StringUtil.js","../src/ZoneId.js","../src/zone/ZoneRules.js","../src/ZoneOffset.js","../src/format/DateTimeBuilder.js","../src/format/DateTimeParseContext.js","../src/format/DateTimePrintContext.js","../src/temporal/IsoFields.js","../src/format/DecimalStyle.js","../src/format/SignStyle.js","../src/format/TextStyle.js","../src/format/parser/CharLiteralPrinterParser.js","../src/format/parser/CompositePrinterParser.js","../src/format/parser/FractionPrinterParser.js","../src/format/parser/NumberPrinterParser.js","../src/format/parser/OffsetIdPrinterParser.js","../src/format/parser/PadPrinterParserDecorator.js","../src/format/parser/SettingsParser.js","../src/format/parser/StringLiteralPrinterParser.js","../src/zone/ZoneRulesProvider.js","../src/ZoneRegion.js","../src/format/parser/ZoneIdPrinterParser.js","../src/format/DateTimeFormatterBuilder.js","../src/format/StringBuilder.js","../src/format/DateTimeFormatter.js","../src/MonthDay.js","../src/YearMonth.js","../src/Year.js","../src/temporal/TemporalAdjuster.js","../src/temporal/TemporalAdjusters.js","../src/chrono/IsoChronology.js","../src/OffsetTime.js","../src/chrono/ChronoZonedDateTime.js","../src/ZonedDateTime.js","../src/OffsetDateTime.js","../src/LocalDate.js","../src/chrono/ChronoLocalDateTime.js","../src/LocalDateTime.js","../src/LocalTime.js","../src/Instant.js","../src/Clock.js","../src/zone/ZoneOffsetTransition.js","../src/temporal/TemporalQueriesFactory.js","../src/zone/SystemDefaultZoneRules.js","../src/zone/SystemDefaultZoneId.js","../src/ZoneIdFactory.js","../src/_init.js","../src/convert.js","../src/nativeJs.js","../src/use.js","../src/js-joda.js"],"sourcesContent":["/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nfunction createErrorType(name, init, superErrorClass = Error) {\n    function JsJodaException(message) {\n        if (!Error.captureStackTrace) {\n            this.stack = (new Error()).stack;\n        } else {\n            Error.captureStackTrace(this, this.constructor);\n        }\n        this.message = message;\n        init && init.apply(this, arguments);\n        this.toString = function () {\n            return `${this.name}: ${this.message}`;\n        };\n    }\n    JsJodaException.prototype = Object.create(superErrorClass.prototype);\n    JsJodaException.prototype.name = name;\n    JsJodaException.prototype.constructor = JsJodaException;\n    return JsJodaException;\n}\n\nexport const DateTimeException = createErrorType('DateTimeException', messageWithCause);\nexport const DateTimeParseException = createErrorType('DateTimeParseException', messageForDateTimeParseException);\nexport const UnsupportedTemporalTypeException = createErrorType('UnsupportedTemporalTypeException', null, DateTimeException);\nexport const ArithmeticException = createErrorType('ArithmeticException');\nexport const IllegalArgumentException = createErrorType('IllegalArgumentException');\nexport const IllegalStateException = createErrorType('IllegalStateException');\nexport const NullPointerException = createErrorType('NullPointerException');\n\nfunction messageWithCause(message, cause = null) {\n    let msg = message || this.name;\n    if (cause !== null && cause instanceof Error) {\n        msg += `\\n-------\\nCaused by: ${cause.stack}\\n-------\\n`;\n    }\n    this.message = msg;\n}\n\nfunction messageForDateTimeParseException(message, text = '', index = 0, cause = null) {\n    let msg = message || this.name;\n    msg += `: ${text}, at index: ${index}`;\n    if (cause !== null && cause instanceof Error) {\n        msg += `\\n-------\\nCaused by: ${cause.stack}\\n-------\\n`;\n    }\n    this.message = msg;\n    this.parsedString = () => {\n        return text;\n    };\n    this.errorIndex = () => {\n        return index;\n    };\n}\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nimport { NullPointerException, IllegalArgumentException } from './errors';\n\n/**\n * @private\n *\n * @param assertion\n * @param msg\n * @param error\n */\nexport function assert(assertion, msg, error) {\n    if(!assertion){\n        if (error) {\n            throw new error(msg);\n        } else {\n            throw new Error(msg);\n        }\n    }\n}\n\n/**\n * @private\n *\n * @param value\n * @param parameterName\n * @returns {*}\n */\nexport function requireNonNull(value, parameterName) {\n    if (value == null) {\n        throw new NullPointerException(`${parameterName} must not be null`);\n    }\n    return value;\n}\n\n/**\n * @private\n *\n * @param value\n * @param _class\n * @param parameterName\n * @returns {_class}\n */\nexport function requireInstance(value, _class, parameterName) {\n    if (!(value instanceof _class)) {\n        throw new IllegalArgumentException(`${parameterName} must be an instance of ${_class.name ? _class.name : _class}${value && value.constructor && value.constructor.name ? `, but is ${value.constructor.name}` : ''}`);\n    }\n    return value;\n}\n\n/**\n * @private\n *\n * @param methodName\n */\nexport function abstractMethodFail(methodName){\n    throw new TypeError(`abstract method \"${methodName}\" is not implemented`);\n}\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nimport { ArithmeticException } from './errors';\n\nexport const MAX_SAFE_INTEGER = 9007199254740991;\nexport const MIN_SAFE_INTEGER = -9007199254740991;\n\n/**\n * Math helper with static function for integer operations\n */\nexport class MathUtil {\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static intDiv(x, y) {\n        let r = x/y;\n        r = MathUtil.roundDown(r);\n        return MathUtil.safeZero(r);\n    }\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static intMod(x, y) {\n        let r = x - MathUtil.intDiv(x, y) * y;\n        r = MathUtil.roundDown(r);\n        return MathUtil.safeZero(r);\n    }\n\n    /**\n     *\n     * @param {number} r\n     * @returns {number}\n     */\n    static roundDown(r){\n        if (r < 0) {\n            return Math.ceil(r);\n        } else {\n            return Math.floor(r);\n        }\n    }\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static floorDiv(x, y){\n        const r = Math.floor(x / y);\n        return MathUtil.safeZero(r);\n    }\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static floorMod(x, y){\n        const r = x - MathUtil.floorDiv(x, y) * y;\n        return MathUtil.safeZero(r);\n    }\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static safeAdd(x, y) {\n        MathUtil.verifyInt(x);\n        MathUtil.verifyInt(y);\n        if (x === 0) {\n            return MathUtil.safeZero(y);\n        }\n        if (y === 0) {\n            return MathUtil.safeZero(x);\n        }\n        const r = MathUtil.safeToInt(x + y);\n        if (r === x || r === y) {\n            throw new ArithmeticException('Invalid addition beyond MAX_SAFE_INTEGER!');\n        }\n        return r;\n    }\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static safeSubtract(x, y) {\n        MathUtil.verifyInt(x);\n        MathUtil.verifyInt(y);\n        if (x === 0 && y === 0) {\n            return 0;\n        } else if (x === 0) {\n            return MathUtil.safeZero(-1 * y);\n        } else if (y === 0) {\n            return MathUtil.safeZero(x);\n        }\n        return MathUtil.safeToInt(x - y);\n    }\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static safeMultiply(x, y) {\n        MathUtil.verifyInt(x);\n        MathUtil.verifyInt(y);\n        if (x === 1) {\n            return MathUtil.safeZero(y);\n        }\n        if (y === 1) {\n            return MathUtil.safeZero(x);\n        }\n        if (x === 0 || y === 0) {\n            return 0;\n        }\n        const r = MathUtil.safeToInt(x * y);\n        if (r / y !== x || (x === MIN_SAFE_INTEGER && y === -1) || (y === MIN_SAFE_INTEGER && x === -1)) {\n            throw new ArithmeticException(`Multiplication overflows: ${x} * ${y}`);\n        }\n        return r;\n    }\n\n    /**\n     *\n     * @param {number} value\n     * @returns {number}\n     */\n    static parseInt(value) {\n        const r = parseInt(value);\n        return MathUtil.safeToInt(r);\n    }\n\n    /**\n     *\n     * @param {number} value\n     * @returns {number}\n     */\n    static safeToInt(value) {\n        MathUtil.verifyInt(value);\n        return MathUtil.safeZero(value);\n    }\n\n    /**\n     *\n     * @param {number} value\n     */\n    static verifyInt(value){\n        if (value == null) {\n            throw new ArithmeticException(`Invalid value: '${value}', using null or undefined as argument`);\n        }\n        if (isNaN(value)) {\n            throw new ArithmeticException('Invalid int value, using NaN as argument');\n        }\n        if ((value % 1) !== 0) {\n            throw new ArithmeticException(`Invalid value: '${value}' is a float`);\n        }\n        if (value > MAX_SAFE_INTEGER || value < MIN_SAFE_INTEGER) {\n            throw new ArithmeticException(`Calculation overflows an int: ${value}`);\n        }\n    }\n\n    /**\n     * convert -0 to 0 and int as string to a number ( '1' -> 1 )\n     *\n     * @param {number} value\n     * @returns {number}\n     */\n    static safeZero(value){\n        return value === 0 ? 0 : +value;\n    }\n\n    /**\n     * Compares two Numbers.\n     *\n     * @param {number} a  the first value\n     * @param {number} b  the second value\n     * @return {number} the result\n     */\n    static compareNumbers(a, b) {\n        if (a < b) {\n            return -1;\n        }\n        if (a > b) {\n            return 1;\n        }\n        return 0;\n    }\n\n    // convert to small integer for v8 optimisation\n    static smi(int) {\n        return ((int >>> 1) & 0x40000000) | (int & 0xBFFFFFFF);\n    }\n\n    // calculate 32 bit hash of a number and convert to SMI\n    static hash(number) {\n        if (number !== number || number === Infinity) {\n            return 0;\n        }\n        let result = number;\n        while (number > 0xFFFFFFFF) {\n            number /= 0xFFFFFFFF;\n            result ^= number;\n        }\n        return MathUtil.smi(result);\n    }\n\n    // default hashCode calculation for a number sequence as mentioned by Joshua Bloch\n    static hashCode(...numbers) {\n        let result = 17;\n        for (const n of numbers) {\n            result = (result << 5) - result + MathUtil.hash(n);\n        }\n        return MathUtil.hash(result);\n    }\n}\n\nMathUtil.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;\nMathUtil.MIN_SAFE_INTEGER = MIN_SAFE_INTEGER;\n\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n/***\n * Base class for a pseudo enum\n */\nexport class Enum {\n    constructor(name){\n        this._name = name;\n    }\n\n    equals(other){\n        return this === other;\n    }\n\n    toString() {\n        return this._name;\n    }\n\n    /**\n     * toJSON() use by JSON.stringify\n     * delegates to toString()\n     *\n     * @return {string}\n     */\n    toJSON() {\n        return this.toString();\n    }\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { abstractMethodFail } from '../assert';\n\n/**\n * Framework-level interface defining an amount of time, such as\n * \"6 hours\", \"8 days\" or \"2 years and 3 months\".\n *\n * This is the base interface type for amounts of time.\n * An amount is distinct from a date or time-of-day in that it is not tied\n * to any specific point on the time-line.\n *\n * The amount can be thought of as a {@link Map} of {@link TemporalUnit} to\n * `long`, exposed via {@link getUnits} and {@link get}.\n * A simple case might have a single unit-value pair, such as \"6 hours\".\n * A more complex case may have multiple unit-value pairs, such as\n * \"7 years, 3 months and 5 days\".\n *\n * There are two common implementations.\n * {@link Period} is a date-based implementation, storing years, months and days.\n * {@link Duration} is a time-based implementation, storing seconds and nanoseconds,\n * but providing some access using other duration based units such as minutes,\n * hours and fixed 24-hour days.\n *\n * This interface is a framework-level interface that should not be widely\n * used in application code. Instead, applications should create and pass\n * around instances of concrete types, such as {@link Period} and {@link Duration}.\n *\n * @interface\n */\nexport class TemporalAmount {\n    /**\n     * Returns the value of the requested unit.\n     * The units returned from {@link getUnits} uniquely define the\n     * value of the {@link TemporalAmount}.  A value must be returned\n     * for each unit listed in {@link getUnits}.\n     *\n     * @implSpec\n     * Implementations may declare support for units not listed by {@link getUnits}.\n     * Typically, the implementation would define additional units\n     * as conversions for the convenience of developers.\n     *\n     * @param {TemporalUnit} unit - the {@link TemporalUnit} for which to return the value\n     * @return {number} the long value of the unit\n     * @throws DateTimeException if a value for the unit cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the {@link unit} is not supported\n     */\n    // eslint-disable-next-line no-unused-vars\n    get(unit) {\n        abstractMethodFail('get');\n    }\n    \n    /**\n     * Returns the list of units uniquely defining the value of this TemporalAmount.\n     * The list of {@link TemporalUnits} is defined by the implementation class.\n     * The list is a snapshot of the units at the time {@link getUnits}\n     * is called and is not mutable.\n     * The units are ordered from longest duration to the shortest duration\n     * of the unit.\n     *\n     * @implSpec\n     * The list of units completely and uniquely represents the\n     * state of the object without omissions, overlaps or duplication.\n     * The units are in order from longest duration to shortest.\n     *\n     * @return {TemporalUnit[]} the List of {@link TemporalUnits}; not null\n     */\n    units() {\n        abstractMethodFail('units');\n    }\n    \n    /**\n     * Adds to the specified temporal object.\n     *\n     * Adds the amount to the specified temporal object using the logic\n     * encapsulated in the implementing class.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#plus}:\n     * <pre>\n     *   // These two lines are equivalent, but the second approach is recommended\n     *   dateTime = amount.addTo(dateTime);\n     *   dateTime = dateTime.plus(adder);\n     * </pre>\n     * It is recommended to use the second approach, {@link plus},\n     * as it is a lot clearer to read in code.\n     *\n     * @implSpec\n     * The implementation must take the input object and add to it.\n     * The implementation defines the logic of the addition and is responsible for\n     * documenting that logic. It may use any method on {@link Temporal} to\n     * query the temporal object and perform the addition.\n     * The returned object must have the same observable type as the input object\n     *\n     * The input object must not be altered.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable temporal objects.\n     *\n     * The input temporal object may be in a calendar system other than ISO.\n     * Implementations may choose to document compatibility with other calendar systems,\n     * or reject non-ISO temporal objects by querying the chronology (see {@link TemporalQueries#chronology}).\n     *\n     * This method may be called from multiple threads in parallel.\n     * It must be thread-safe when invoked.\n     *\n     * @param {Temporal} temporal - the temporal object to add the amount to, not null\n     * @return {Temporal} an object of the same observable type with the addition made, not null\n     * @throws DateTimeException if unable to add\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    // eslint-disable-next-line no-unused-vars\n    addTo(temporal) {\n        abstractMethodFail('addTo');\n    }\n    \n    /**\n     * Subtracts this object from the specified temporal object.\n     *\n     * Subtracts the amount from the specified temporal object using the logic\n     * encapsulated in the implementing class.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#minus}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   dateTime = amount.subtractFrom(dateTime);\n     *   dateTime = dateTime.minus(amount);\n     * </pre>\n     * It is recommended to use the second approach, {@link minus},\n     * as it is a lot clearer to read in code.\n     *\n     * @implSpec\n     * The implementation must take the input object and subtract from it.\n     * The implementation defines the logic of the subtraction and is responsible for\n     * documenting that logic. It may use any method on {@link Temporal} to\n     * query the temporal object and perform the subtraction.\n     * The returned object must have the same observable type as the input object\n     *\n     * The input object must not be altered.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable temporal objects.\n     *\n     * The input temporal object may be in a calendar system other than ISO.\n     * Implementations may choose to document compatibility with other calendar systems,\n     * or reject non-ISO temporal objects by querying the chronology (see {@link TemporalQueries#chronology}).\n     *\n     * This method may be called from multiple threads in parallel.\n     * It must be thread-safe when invoked.\n     *\n     * @param {Temporal} temporal - the temporal object to subtract the amount from, not null\n     * @return {Temporal} an object of the same observable type with the subtraction made, not null\n     * @throws DateTimeException if unable to subtract\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    // eslint-disable-next-line no-unused-vars\n    subtractFrom(temporal) {\n        abstractMethodFail('subtractFrom');\n    }\n    \n}\n\nif (typeof Symbol !== 'undefined' && Symbol.toPrimitive) {\n    TemporalAmount.prototype[Symbol.toPrimitive] = function (hint) {\n        // hint could be 'number', 'string' or 'default'. Only 'number'\n        // should throw and 'default' is treated as 'string'.\n        if (hint !== 'number') {\n            return this.toString();\n        }\n\n        throw new TypeError(\n            'A conversion from TemporalAmount to a number is not allowed. ' +\n            'To compare use the methods .equals(), .compareTo(), .isBefore() ' +\n            'or one that is more suitable to your use case.'\n        );\n    };\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { abstractMethodFail } from '../assert';\n\n/**\n * A unit of date-time, such as Days or Hours.\n *\n * Measurement of time is built on units, such as years, months, days, hours, minutes and seconds.\n * Implementations of this interface represent those units.\n *\n * An instance of this interface represents the unit itself, rather than an amount of the unit.\n * See {@link Period} for a class that represents an amount in terms of the common units.\n *\n * The most commonly used units are defined in {@link ChronoUnit}.\n * Further units are supplied in {@link IsoFields}.\n * Units can also be written by application code by implementing this interface.\n *\n * The unit works using double dispatch. Client code calls methods on a date-time like\n * {@link LocalDateTime} which check if the unit is a {@link ChronoUnit}.\n * If it is, then the date-time must handle it.\n * Otherwise, the method call is re-dispatched to the matching method in this interface.\n *\n * @interface\n */\nexport class TemporalUnit {\n    /**\n     * Gets the duration of this unit, which may be an estimate.\n     *\n     * All units return a duration measured in standard nanoseconds from this method.\n     * The duration will be positive and non-zero.\n     * For example, an hour has a duration of `60 * 60 * 1,000,000,000 ns`.\n     *\n     * Some units may return an accurate duration while others return an estimate.\n     * For example, days have an estimated duration due to the possibility of\n     * daylight saving time changes.\n     * To determine if the duration is an estimate, use {@link isDurationEstimated}.\n     *\n     * @return {Duration} the duration of this unit, which may be an estimate.\n     */\n    duration() {\n        abstractMethodFail('duration');\n    }\n\n    /**\n     * Checks if the duration of the unit is an estimate.\n     *\n     * All units have a duration, however the duration is not always accurate.\n     * For example, days have an estimated duration due to the possibility of\n     * daylight saving time changes.\n     * This method returns true if the duration is an estimate and false if it is\n     * accurate. Note that accurate/estimated ignores leap seconds.\n     *\n     * @return {boolean} `true` if the duration is estimated, `false` if accurate.\n     */\n    isDurationEstimated() {\n        abstractMethodFail('isDurationEstimated');\n    }\n\n    /**\n     * Checks if this unit is date-based.\n     *\n     * @return {boolean} `true` if date unit, `false` if a time unit.\n     */\n    isDateBased() {\n        abstractMethodFail('isDateBased');\n    }\n\n    /**\n     * Checks if this unit is time-based.\n     *\n     * @return {boolean} `true` if time unit, `false` if a date unit.\n     */\n    isTimeBased() {\n        abstractMethodFail('isTimeBased');\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this unit is supported by the specified temporal object.\n     *\n     * This checks that the implementing date-time can add/subtract this unit.\n     * This can be used to avoid throwing an exception.\n     *\n     * @param {!Temporal} temporal the temporal object to check.\n     * @return {boolean} `true` if the unit is supported.\n     */\n    // eslint-disable-next-line no-unused-vars\n    isSupportedBy(temporal) {\n        abstractMethodFail('isSupportedBy');\n    }\n\n    /**\n     * Returns a copy of the specified temporal object with the specified period added.\n     *\n     * The period added is a multiple of this unit. For example, this method\n     * could be used to add \"3 days\" to a date by calling this method on the\n     * instance representing \"days\", passing the date and the period \"3\".\n     * The period to be added may be negative, which is equivalent to subtraction.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#plus}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisUnit.doPlus(temporal);\n     *   temporal = temporal.plus(thisUnit);\n     * </pre>\n     * It is recommended to use the second approach, {@link plus},\n     * as it is a lot clearer to read in code.\n     *\n     * Implementations should perform any queries or calculations using the units\n     * available in {@link ChronoUnit} or the fields available in {@link ChronoField}.\n     * If the field is not supported a {@link DateTimeException} must be thrown.\n     *\n     * Implementations must not alter the specified temporal object.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable implementations.\n     *\n     * @param {!Temporal} dateTime the temporal object to adjust.\n     * @param {number} periodToAdd the period of this unit to add, positive or negative.\n     * @return {Temporal} the adjusted temporal object.\n     * @throws DateTimeException if the period cannot be added.\n     */\n    // eslint-disable-next-line no-unused-vars\n    addTo(dateTime, periodToAdd) {\n        abstractMethodFail('addTo');\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Calculates the period in terms of this unit between two temporal objects of the same type.\n     *\n     * This calculates the period between two temporals in terms of this unit.\n     * The start and end points are supplied as temporal objects and must be of the same type.\n     * The result will be negative if the end is before the start.\n     * For example, the period in hours between two temporal objects can be calculated\n     * using {@link HOURS.between}.\n     *\n     * The calculation returns a whole number, representing the number of complete units between the two temporals.\n     * For example, the period in hours between the times 11:30 and 13:29 will only be\n     * one hour as it is one minute short of two hours.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#until}:\n     * <pre>\n     *   // these two lines are equivalent\n     *   between = thisUnit.between(start, end);\n     *   between = start.until(end, thisUnit);\n     * </pre>\n     * The choice should be made based on which makes the code more readable.\n     *\n     * For example, this method allows the number of days between two dates to be calculated:\n     * <pre>\n     *   long daysBetween = DAYS.between(start, end);\n     *   // or alternatively\n     *   long daysBetween = start.until(end, DAYS);\n     * </pre>\n     * Implementations should perform any queries or calculations using the units available in\n     * {@link ChronoUnit} or the fields available in {@link ChronoField}.\n     * If the unit is not supported a {@link DateTimeException} must be thrown.\n     * Implementations must not alter the specified temporal objects.\n     *\n     * @param {!Temporal} temporal1 the base temporal object.\n     * @param {!Temporal} temporal2 the other temporal object.\n     * @return {number} the period between temporal1 and temporal2 in terms of this unit;\n     *  positive if temporal2 is later than temporal1, negative if earlier.\n     * @throws DateTimeException if the period cannot be calculated.\n     * @throws ArithmeticException if numeric overflow occurs.\n     */\n    // eslint-disable-next-line no-unused-vars\n    between(temporal1, temporal2) {\n        abstractMethodFail('between');\n    }\n}\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nimport { requireNonNull, requireInstance } from './assert';\nimport { ArithmeticException, DateTimeParseException, UnsupportedTemporalTypeException } from './errors';\nimport { MathUtil, MAX_SAFE_INTEGER, MIN_SAFE_INTEGER } from './MathUtil';\n\nimport { ChronoField } from './temporal/ChronoField';\nimport { ChronoUnit } from './temporal/ChronoUnit';\nimport { TemporalAmount } from './temporal/TemporalAmount';\nimport { TemporalUnit } from './temporal/TemporalUnit';\n\nimport { LocalTime } from './LocalTime';\n\n/**\n * A time-based amount of time, such as '34.5 seconds'.\n *\n * This class models a quantity or amount of time in terms of seconds and nanoseconds.\n * It can be accessed using other duration-based units, such as minutes and hours.\n * In addition, the {@link ChronoUnit#DAYS} unit can be used and is treated as\n * exactly equal to 24 hours, thus ignoring daylight savings effects.\n * See {@link Period} for the date-based equivalent to this class.\n *\n * A physical duration could be of infinite length.\n * For practicality, the duration is stored with constraints similar to {@link Instant}.\n * The duration uses nanosecond resolution with a maximum value of the seconds that can\n * be held in a `long`. This is greater than the current estimated age of the universe.\n *\n * The range of a duration requires the storage of a number larger than a `long`.\n * To achieve this, the class stores a `long` representing seconds and an `int`\n * representing nanosecond-of-second, which will always be between 0 and 999,999,999.\n *\n * The duration is measured in \"seconds\", but these are not necessarily identical to\n * the scientific \"SI second\" definition based on atomic clocks.\n * This difference only impacts durations measured near a leap-second and should not affect\n * most applications.\n * See {@link Instant} for a discussion as to the meaning of the second and time-scales.\n *\n * ### Static properties of Class {@link Duration}\n *\n * Duration.ZERO\n *\n * Constant for a duration of zero.\n *\n */\nexport class Duration extends TemporalAmount /*implements TemporalAmount, Comparable<Duration>, Serializable */ {\n\n    /**\n     * Constructs an instance of {@link Duration} using seconds and nanoseconds.\n     *\n     * @param {Number} seconds - the length of the duration in seconds, positive or negative\n     * @param {Number} nanos - the nanoseconds within the second, from 0 to 999,999,999\n     * @private\n     */\n    constructor(seconds, nanos) {\n        super();\n        this._seconds = MathUtil.safeToInt(seconds);\n        this._nanos = MathUtil.safeToInt(nanos);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from a number of standard 24 hour days.\n     *\n     * The seconds are calculated based on the standard definition of a day,\n     * where each day is 86400 seconds which implies a 24 hour day.\n     * The nanosecond in second field is set to zero.\n     *\n     * @param {Number} days - the number of days, positive or negative\n     * @return {!Duration}\n     * @throws ArithmeticException if the input days exceeds the capacity of {@link Duration}\n     */\n    static ofDays(days) {\n        return Duration._create(MathUtil.safeMultiply(days, LocalTime.SECONDS_PER_DAY), 0);\n    }\n\n    /**\n     * Obtains an instance of {@link Duration} from a number of standard hours.\n     *\n     * The seconds are calculated based on the standard definition of an hour,\n     * where each hour is 3600 seconds.\n     * The nanosecond in second field is set to zero.\n     *\n     * @param {Number} hours - the number of hours, positive or negative\n     * @return {!Duration}\n     * @throws ArithmeticException if the input hours exceeds the capacity of {@link Duration}\n     */\n    static ofHours(hours) {\n        return Duration._create(MathUtil.safeMultiply(hours, LocalTime.SECONDS_PER_HOUR), 0);\n    }\n\n    /**\n     * Obtains an instance of {@link Duration} from a number of standard minutes.\n     *\n     * The seconds are calculated based on the standard definition of a minute,\n     * where each minute is 60 seconds.\n     * The nanosecond in second field is set to zero.\n     *\n     * @param {Number} minutes - the number of minutes, positive or negative\n     * @return {!Duration}\n     * @throws ArithmeticException if the input minutes exceeds the capacity of {@link Duration}\n     */\n    static ofMinutes(minutes) {\n        return Duration._create(MathUtil.safeMultiply(minutes, LocalTime.SECONDS_PER_MINUTE), 0);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from a number of seconds\n     * and an adjustment in nanoseconds.\n     *\n     * This method allows an arbitrary number of nanoseconds to be passed in.\n     * The factory will alter the values of the second and nanosecond in order\n     * to ensure that the stored nanosecond is in the range 0 to 999,999,999.\n     * For example, the following will result in the exactly the same duration:\n     * <pre>\n     *  Duration.ofSeconds(3, 1);\n     *  Duration.ofSeconds(4, -999_999_999);\n     *  Duration.ofSeconds(2, 1000_000_001);\n     * </pre>\n     *\n     * @param {Number} seconds - the number of seconds, positive or negative\n     * @param {Number} nanoAdjustment  the nanosecond adjustment to the number of seconds, positive or negative\n     * @return {!Duration}\n     * @throws ArithmeticException if the adjustment causes the seconds to exceed the capacity of {@link Duration}\n     */\n    static ofSeconds(seconds, nanoAdjustment = 0) {\n        const secs = MathUtil.safeAdd(seconds, MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND));\n        const nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);\n        return Duration._create(secs, nos);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from a number of milliseconds.\n     *\n     * The seconds and nanoseconds are extracted from the specified milliseconds.\n     *\n     * @param {Number} millis - the number of milliseconds, positive or negative\n     * @return {!Duration}\n     */\n    static ofMillis(millis) {\n        let secs = MathUtil.intDiv(millis, 1000);\n        let mos = MathUtil.intMod(millis, 1000);\n        if (mos < 0) {\n            mos += 1000;\n            secs--;\n        }\n        return Duration._create(secs, mos * 1000000);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from a number of nanoseconds.\n     *\n     * The seconds and nanoseconds are extracted from the specified nanoseconds.\n     *\n     * @param {Number} nanos - the number of nanoseconds, positive or negative\n     * @return {!Duration}\n     */\n    static ofNanos(nanos) {\n        let secs = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_SECOND);\n        let nos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_SECOND);\n        if (nos < 0) {\n            nos += LocalTime.NANOS_PER_SECOND;\n            secs--;\n        }\n        return this._create(secs, nos);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from a duration in the specified unit.\n     *\n     * The parameters represent the two parts of a phrase like '6 Hours'. For example:\n     * <pre>\n     *  Duration.of(3, SECONDS);\n     *  Duration.of(465, HOURS);\n     * </pre>\n     * Only a subset of units are accepted by this method.\n     * The unit must either have an exact duration (see {@link TemporalUnit#isDurationEstimated}) or\n     * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.\n     *\n     * @param {Number} amount - the amount of the duration, measured in terms of the unit, positive or negative\n     * @param {TemporalUnit} unit - the unit that the duration is measured in, must have an exact duration, not null\n     * @return {!Duration}\n     * @throws DateTimeException if the period unit has an estimated duration\n     * @throws ArithmeticException if a numeric overflow occurs\n     */\n    static of(amount, unit) {\n        return Duration.ZERO.plus(amount, unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from an amount.\n     *\n     * This obtains a duration based on the specified amount.\n     * A TemporalAmount represents an amount of time, which may be date-based\n     * or time-based, which this factory extracts to a duration.\n     *\n     * The conversion loops around the set of units from the amount and uses\n     * the duration of the unit to calculate the total Duration.\n     * Only a subset of units are accepted by this method.\n     * The unit must either have an exact duration or be ChronoUnit.DAYS which\n     * is treated as 24 hours. If any other units are found then an exception is thrown.\n     *\n     * @param {TemporalAmount} amount - the temporal amount to convert, not null\n     * @return {Duration} the resulting duration, not null\n     * @throws DateTimeException if the amount cannot be converted\n     * @throws ArithmeticException if a numeric overflow occurs\n     */\n    static from(amount) {\n        requireNonNull(amount, 'amount');\n        requireInstance(amount, TemporalAmount);\n        let duration = Duration.ZERO;\n        amount.units().forEach((unit) => {\n            duration = duration.plus(amount.get(unit), unit);\n        });\n        return duration;\n    }\n\n    /**\n     * Obtains an instance of {@link Duration} representing the duration between two instants.\n     *\n     * Obtains a {@link Duration} representing the duration between two instants.\n     * This calculates the duration between two temporal objects of the same type.\n     * The difference in seconds is calculated using {@link Temporal#until}.\n     * The difference in nanoseconds is calculated using by querying the\n     * {@link ChronoField#NANO_OF_SECOND} field.\n     *\n     * The result of this method can be a negative period if the end is before the start.\n     * To guarantee to obtain a positive duration call abs() on the result.\n     *\n     * @param {Temporal} startInclusive - the start instant, inclusive, not null\n     * @param {Temporal} endExclusive - the end instant, exclusive, not null\n     * @return {!Duration}\n     * @throws DateTimeException if the seconds between the temporals cannot be obtained\n     * @throws ArithmeticException if the calculation exceeds the capacity of {@link Duration}\n     */\n    static between(startInclusive, endExclusive) {\n        requireNonNull(startInclusive, 'startInclusive');\n        requireNonNull(endExclusive, 'endExclusive');\n        let secs = startInclusive.until(endExclusive, ChronoUnit.SECONDS);\n        let nanos = 0;\n        if (startInclusive.isSupported(ChronoField.NANO_OF_SECOND) && endExclusive.isSupported(ChronoField.NANO_OF_SECOND)) {\n            try {\n                const startNos = startInclusive.getLong(ChronoField.NANO_OF_SECOND);\n                nanos = endExclusive.getLong(ChronoField.NANO_OF_SECOND) - startNos;\n                if (secs > 0 && nanos < 0) {\n                    nanos += LocalTime.NANOS_PER_SECOND;\n                } else if (secs < 0 && nanos > 0) {\n                    nanos -= LocalTime.NANOS_PER_SECOND;\n                } else if (secs === 0 && nanos !== 0) {\n                    // two possible meanings for result, so recalculate secs\n                    const adjustedEnd = endExclusive.with(ChronoField.NANO_OF_SECOND, startNos);\n                    secs = startInclusive.until(adjustedEnd, ChronoUnit.SECONDS);\n                }\n            } catch (e) {\n                // ignore and only use seconds\n            }\n        }\n        return this.ofSeconds(secs, nanos);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a {@link Duration} from a text string such as {@link PnDTnHnMn.nS}.\n     *\n     * This will parse a textual representation of a duration, including the\n     * string produced by {@link toString}. The formats accepted are based\n     * on the ISO-8601 duration format {@link PnDTnHnMn.nS} with days\n     * considered to be exactly 24 hours.\n     *\n     * The string starts with an optional sign, denoted by the ASCII negative\n     * or positive symbol. If negative, the whole period is negated.\n     * The ASCII letter \"P\" is next in upper or lower case.\n     * There are then four sections, each consisting of a number and a suffix.\n     * The sections have suffixes in ASCII of \"D\", \"H\", \"M\" and \"S\" for\n     * days, hours, minutes and seconds, accepted in upper or lower case.\n     * The suffixes must occur in order. The ASCII letter \"T\" must occur before\n     * the first occurrence, if any, of an hour, minute or second section.\n     * At least one of the four sections must be present, and if \"T\" is present\n     * there must be at least one section after the \"T\".\n     * The number part of each section must consist of one or more ASCII digits.\n     * The number may be prefixed by the ASCII negative or positive symbol.\n     * The number of days, hours and minutes must parse to a `long`.\n     * The number of seconds must parse to a `long` with optional fraction.\n     * The decimal point may be either a dot or a comma.\n     * The fractional part may have from zero to 9 digits.\n     *\n     * The leading plus/minus sign, and negative values for other units are\n     * not part of the ISO-8601 standard.\n     *\n     * Examples:\n     * <pre>\n     *    \"PT20.345S\" -> parses as \"20.345 seconds\"\n     *    \"PT15M\"     -> parses as \"15 minutes\" (where a minute is 60 seconds)\n     *    \"PT10H\"     -> parses as \"10 hours\" (where an hour is 3600 seconds)\n     *    \"P2D\"       -> parses as \"2 days\" (where a day is 24 hours or 86400 seconds)\n     *    \"P2DT3H4M\"  -> parses as \"2 days, 3 hours and 4 minutes\"\n     *    \"P-6H3M\"    -> parses as \"-6 hours and +3 minutes\"\n     *    \"-P6H3M\"    -> parses as \"-6 hours and -3 minutes\"\n     *    \"-P-6H+3M\"  -> parses as \"+6 hours and -3 minutes\"\n     * </pre>\n     *\n     * @param {String} text - the text to parse, not null\n     * @return {Duration} the parsed duration, not null\n     * @throws DateTimeParseException if the text cannot be parsed to a duration\n     */\n    static parse(text) {\n        requireNonNull(text, 'text');\n        /**\n         * The pattern for parsing.\n         */\n        const PATTERN = new RegExp('([-+]?)P(?:([-+]?[0-9]+)D)?(T(?:([-+]?[0-9]+)H)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)(?:[.,]([0-9]{0,9}))?S)?)?', 'i');\n        const matches = PATTERN.exec(text);\n        if (matches !== null) {\n            // check for letter T but no time sections\n            if ('T' === matches[3] === false) {\n                const negate = '-' === matches[1];\n                const dayMatch = matches[2];\n                const hourMatch = matches[4];\n                const minuteMatch = matches[5];\n                const secondMatch = matches[6];\n                const fractionMatch = matches[7];\n                if (dayMatch != null || hourMatch != null || minuteMatch != null || secondMatch != null) {\n                    const daysAsSecs = Duration._parseNumber(text, dayMatch, LocalTime.SECONDS_PER_DAY, 'days');\n                    const hoursAsSecs = Duration._parseNumber(text, hourMatch, LocalTime.SECONDS_PER_HOUR, 'hours');\n                    const minsAsSecs = Duration._parseNumber(text, minuteMatch, LocalTime.SECONDS_PER_MINUTE, 'minutes');\n                    const seconds = Duration._parseNumber(text, secondMatch, 1, 'seconds');\n                    const negativeSecs = secondMatch != null && secondMatch.charAt(0) === '-';\n                    const nanos = Duration._parseFraction(text,  fractionMatch, negativeSecs ? -1 : 1);\n                    try {\n                        return Duration._create(negate, daysAsSecs, hoursAsSecs, minsAsSecs, seconds, nanos);\n                    } catch (ex) {\n                        throw new DateTimeParseException('Text cannot be parsed to a Duration: overflow', text, 0, ex);\n                    }\n                }\n            }\n        }\n        throw new DateTimeParseException('Text cannot be parsed to a Duration', text, 0);\n    }\n\n    static _parseNumber(text, parsed, multiplier, errorText) {\n        // regex limits to [-+]?[0-9]+\n        if (parsed == null) {\n            return 0;\n        }\n        try {\n            if (parsed[0] === '+') {\n                parsed = parsed.substring(1);\n            }\n            return MathUtil.safeMultiply(parseFloat(parsed), multiplier);\n        } catch (ex) {\n            throw new DateTimeParseException(`Text cannot be parsed to a Duration: ${errorText}`, text, 0, ex);\n        }\n    }\n\n    static _parseFraction(text, parsed, negate) {\n        // regex limits to [0-9]{0,9}\n        if (parsed == null || parsed.length === 0) {\n            return 0;\n        }\n        parsed = (`${parsed}000000000`).substring(0, 9);\n        return parseFloat(parsed) * negate;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * to handle function overriding this function accepts any number of arguments, checks their type and delegates to the appropriate\n     * function\n     *\n     * @return {Duration}\n     */\n    static _create() {\n        if (arguments.length <= 2) {\n            return Duration._createSecondsNanos(arguments[0], arguments[1]);\n        } else {\n            return Duration._createNegateDaysHoursMinutesSecondsNanos(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);\n        }\n    }\n\n    static _createNegateDaysHoursMinutesSecondsNanos(negate, daysAsSecs, hoursAsSecs, minsAsSecs, secs, nanos) {\n        const seconds = MathUtil.safeAdd(daysAsSecs, MathUtil.safeAdd(hoursAsSecs, MathUtil.safeAdd(minsAsSecs, secs)));\n        if (negate) {\n            return Duration.ofSeconds(seconds, nanos).negated();\n        }\n        return Duration.ofSeconds(seconds, nanos);\n    }\n\n    /**\n     * Obtains an instance of {@link Duration} using seconds and nanoseconds.\n     *\n     * @param {Number} seconds - the length of the duration in seconds, positive or negative\n     * @param {Number} nanoAdjustment - the nanosecond adjustment within the second, from 0 to 999,999,999\n     */\n    static _createSecondsNanos(seconds = 0, nanoAdjustment = 0) {\n        if (seconds === 0 && nanoAdjustment === 0) {\n            return Duration.ZERO;\n        }\n        return new Duration(seconds, nanoAdjustment);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the value of the requested unit.\n     *\n     * This returns a value for each of the two supported units,\n     * {@link ChronoUnit#SECONDS} and {@link ChronoUnit#NANOS}.\n     * All other units throw an exception.\n     *\n     * @param {TemporalUnit} unit the {@link TemporalUnit} for which to return the value\n     * @return {number} the const value of the unit\n     * @throws DateTimeException if the unit is not supported\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     */\n    get(unit) {\n        if (unit === ChronoUnit.SECONDS) {\n            return this._seconds;\n        } else if (unit === ChronoUnit.NANOS) {\n            return this._nanos;\n        } else {\n            throw new UnsupportedTemporalTypeException(`Unsupported unit: ${unit}`);\n        }\n    }\n\n    units() {\n        return [ChronoUnit.SECONDS, ChronoUnit.NANOS];\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this duration is zero length.\n     *\n     * A {@link Duration} represents a directed distance between two points on\n     * the time-line and can therefore be positive, zero or negative.\n     * This method checks whether the length is zero.\n     *\n     * @return {boolean} true if this duration has a total length equal to zero\n     */\n    isZero() {\n        return this._seconds === 0 && this._nanos === 0;\n    }\n\n    /**\n     * Checks if this duration is negative, excluding zero.\n     *\n     * A {@link Duration} represents a directed distance between two points on\n     * the time-line and can therefore be positive, zero or negative.\n     * This method checks whether the length is less than zero.\n     *\n     * @return {boolean} true if this duration has a total length less than zero\n     */\n    isNegative() {\n        return this._seconds < 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the number of seconds in this duration.\n     *\n     * The length of the duration is stored using two fields - seconds and nanoseconds.\n     * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to\n     * the length in seconds.\n     * The total duration is defined by calling this method and {@link getNano}.\n     *\n     * A {@link Duration} represents a directed distance between two points on the time-line.\n     * A negative duration is expressed by the negative sign of the seconds part.\n     * A duration of -1 nanosecond is stored as -1 seconds plus 999,999,999 nanoseconds.\n     *\n     * @return {number} the whole seconds part of the length of the duration, positive or negative\n     */\n    seconds() {\n        return this._seconds;\n    }\n\n    /**\n     * Gets the number of nanoseconds within the second in this duration.\n     *\n     * The length of the duration is stored using two fields - seconds and nanoseconds.\n     * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to\n     * the length in seconds.\n     * The total duration is defined by calling this method and {@link getSeconds}.\n     *\n     * A {@link Duration} represents a directed distance between two points on the time-line.\n     * A negative duration is expressed by the negative sign of the seconds part.\n     * A duration of -1 nanosecond is stored as -1 seconds plus 999,999,999 nanoseconds.\n     *\n     * @return {number} the nanoseconds within the second part of the length of the duration, from 0 to 999,999,999\n     */\n    nano() {\n        return this._nanos;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration with the specified amount of seconds.\n     *\n     * This returns a duration with the specified seconds, retaining the\n     * nano-of-second part of this duration.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} seconds - the seconds to represent, may be negative\n     * @return {Duration} based on this period with the requested seconds, not null\n     */\n    withSeconds(seconds) {\n        return Duration._create(seconds, this._nanos);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified nano-of-second.\n     *\n     * This returns a duration with the specified nano-of-second, retaining the\n     * seconds part of this duration.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} nanoOfSecond - the nano-of-second to represent, from 0 to 999,999,999\n     * @return {Duration} based on this period with the requested nano-of-second, not null\n     * @throws DateTimeException if the nano-of-second is invalid\n     */\n    withNanos(nanoOfSecond) {\n        ChronoField.NANO_OF_SECOND.checkValidIntValue(nanoOfSecond);\n        return Duration._create(this._seconds, nanoOfSecond);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration with the specified duration added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Duration} duration - the duration to add, positive or negative, not null\n     * @return {Duration} based on this duration with the specified duration added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusDuration(duration) {\n        requireNonNull(duration, 'duration');\n        return this.plus(duration.seconds(), duration.nano());\n    }\n\n\n    /**\n     * function overloading for {@link Duration.plus}\n     *\n     * if called with 1 arguments, then {@link Duration.plusDuration} is executed.\n     *\n     * if called with 2 arguments and second argument is an instance of TemporalUnit, then {@link Duration.plusAmountUnit} is executed.\n     *\n     * Otherwise {@link Duration.plusSecondsNanos} is executed.\n     *\n     * @param {!(Duration|number)} durationOrNumber\n     * @param {!TemporalUnit|number} unitOrNumber\n     * @returns {Duration}\n     */\n    plus(durationOrNumber, unitOrNumber) {\n        if (arguments.length === 1) {\n            return this.plusDuration(durationOrNumber);\n        }\n        else if (arguments.length === 2 && unitOrNumber instanceof TemporalUnit) {\n            return this.plusAmountUnit(durationOrNumber, unitOrNumber);\n        } else {\n            return this.plusSecondsNanos(durationOrNumber, unitOrNumber);\n        }\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration added.\n     *\n     * The duration amount is measured in terms of the specified unit.\n     * Only a subset of units are accepted by this method.\n     * The unit must either have an exact duration (see {@link TemporalUnit#isDurationEstimated}) or\n     * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} amountToAdd - the amount to add, measured in terms of the unit, positive or negative\n     * @param {TemporalUnit} unit - the unit that the amount is measured in, must have an exact duration, not null\n     * @return {Duration} based on this duration with the specified duration added, not null\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusAmountUnit(amountToAdd, unit) {\n        requireNonNull(amountToAdd, 'amountToAdd');\n        requireNonNull(unit, 'unit');\n        if (unit === ChronoUnit.DAYS) {\n            return this.plusSecondsNanos(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY), 0);\n        }\n        if (unit.isDurationEstimated()) {\n            throw new UnsupportedTemporalTypeException('Unit must not have an estimated duration');\n        }\n        if (amountToAdd === 0) {\n            return this;\n        }\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.NANOS: return this.plusNanos(amountToAdd);\n                case ChronoUnit.MICROS: return this.plusSecondsNanos(MathUtil.intDiv(amountToAdd, (1000000 * 1000)) * 1000, MathUtil.intMod(amountToAdd, (1000000 * 1000)) * 1000);\n                case ChronoUnit.MILLIS: return this.plusMillis(amountToAdd);\n                case ChronoUnit.SECONDS: return this.plusSeconds(amountToAdd);\n            }\n            return this.plusSecondsNanos(MathUtil.safeMultiply(unit.duration().seconds(), amountToAdd), 0);\n        }\n        const duration = unit.duration().multipliedBy(amountToAdd);\n        return this.plusSecondsNanos(duration.seconds(), duration.nano());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration with the specified duration in 24 hour days added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} daysToAdd - the days to add, positive or negative\n     * @return {Duration} based on this duration with the specified days added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusDays(daysToAdd) {\n        return this.plusSecondsNanos(MathUtil.safeMultiply(daysToAdd, LocalTime.SECONDS_PER_DAY), 0);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in hours added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} hoursToAdd - the hours to add, positive or negative\n     * @return {Duration} based on this duration with the specified hours added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusHours(hoursToAdd) {\n        return this.plusSecondsNanos(MathUtil.safeMultiply(hoursToAdd, LocalTime.SECONDS_PER_HOUR), 0);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in minutes added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} minutesToAdd - the minutes to add, positive or negative\n     * @return {Duration} based on this duration with the specified minutes added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusMinutes(minutesToAdd) {\n        return this.plusSecondsNanos(MathUtil.safeMultiply(minutesToAdd, LocalTime.SECONDS_PER_MINUTE), 0);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in seconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} secondsToAdd - the seconds to add, positive or negative\n     * @return {Duration} based on this duration with the specified seconds added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusSeconds(secondsToAdd) {\n        return this.plusSecondsNanos(secondsToAdd, 0);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in milliseconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} millisToAdd - the milliseconds to add, positive or negative\n     * @return {Duration} based on this duration with the specified milliseconds added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusMillis(millisToAdd) {\n        return this.plusSecondsNanos(MathUtil.intDiv(millisToAdd, 1000), MathUtil.intMod(millisToAdd, 1000) * 1000000);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in nanoseconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} nanosToAdd - the nanoseconds to add, positive or negative\n     * @return {Duration} based on this duration with the specified nanoseconds added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusNanos(nanosToAdd) {\n        return this.plusSecondsNanos(0, nanosToAdd);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} secondsToAdd - the seconds to add, positive or negative\n     * @param {Number} nanosToAdd - the nanos to add, positive or negative\n     * @return {Duration} based on this duration with the specified seconds added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusSecondsNanos(secondsToAdd, nanosToAdd) {\n        requireNonNull(secondsToAdd, 'secondsToAdd');\n        requireNonNull(nanosToAdd, 'nanosToAdd');\n        if (secondsToAdd === 0 && nanosToAdd === 0) {\n            return this;\n        }\n        let epochSec = MathUtil.safeAdd(this._seconds, secondsToAdd);\n        epochSec = MathUtil.safeAdd(epochSec, MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND));\n        nanosToAdd = MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_SECOND);\n        const nanoAdjustment = MathUtil.safeAdd(this._nanos, nanosToAdd);  // safe int+LocalTime.NANOS_PER_SECOND\n        return Duration.ofSeconds(epochSec, nanoAdjustment);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link Duration.minus}\n     *\n     * if called with 1 arguments and first argument is an instance of Duration, then {@link Duration.minusDuration} is executed.\n     *\n     * Otherwise {@link Duration.minusAmountUnit} is executed.\n     *\n     * @param {!(Duration|number)} durationOrNumber\n     * @param {?TemporalUnit} unit\n     * @return {Duration}\n     */\n    minus(durationOrNumber, unit) {\n        if (arguments.length === 1) {\n            return this.minusDuration(durationOrNumber);\n        } else {\n            return this.minusAmountUnit(durationOrNumber, unit);\n        }\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Duration} duration - the duration to subtract, positive or negative, not null\n     * @return {Duration} based on this duration with the specified duration subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusDuration(duration) {\n        requireNonNull(duration, 'duration');\n        const secsToSubtract = duration.seconds();\n        const nanosToSubtract = duration.nano();\n        if (secsToSubtract === MIN_SAFE_INTEGER) {\n            return this.plus(MAX_SAFE_INTEGER, -nanosToSubtract);\n        }\n        return this.plus(-secsToSubtract, -nanosToSubtract);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration subtracted.\n     *\n     * The duration amount is measured in terms of the specified unit.\n     * Only a subset of units are accepted by this method.\n     * The unit must either have an exact duration (see {@link TemporalUnit#isDurationEstimated}) or\n     * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} amountToSubtract - the amount to subtract, measured in terms of the unit, positive or negative\n     * @param {TemporalUnit} unit - the unit that the amount is measured in, must have an exact duration, not null\n     * @return {Duration} based on this duration with the specified duration subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusAmountUnit(amountToSubtract, unit) {\n        requireNonNull(amountToSubtract, 'amountToSubtract');\n        requireNonNull(unit, 'unit');\n        return (amountToSubtract === MIN_SAFE_INTEGER ? this.plusAmountUnit(MAX_SAFE_INTEGER, unit) : this.plusAmountUnit(-amountToSubtract, unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration with the specified duration in 24 hour days subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} daysToSubtract - the days to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified days subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusDays(daysToSubtract) {\n        return (daysToSubtract === MIN_SAFE_INTEGER ? this.plusDays(MAX_SAFE_INTEGER) : this.plusDays(-daysToSubtract));\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in hours subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} hoursToSubtract - the hours to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified hours subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusHours(hoursToSubtract) {\n        return (hoursToSubtract === MIN_SAFE_INTEGER ? this.plusHours(MAX_SAFE_INTEGER) : this.plusHours(-hoursToSubtract));\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in minutes subtracted.\n     *\n     * The number of hours is multiplied by 60 to obtain the number of seconds to subtract.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} minutesToSubtract - the minutes to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified minutes subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusMinutes(minutesToSubtract) {\n        return (minutesToSubtract === MIN_SAFE_INTEGER ? this.plusMinutes(MAX_SAFE_INTEGER) : this.plusMinutes(-minutesToSubtract));\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in seconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} secondsToSubtract - the seconds to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified seconds subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusSeconds(secondsToSubtract) {\n        return (secondsToSubtract === MIN_SAFE_INTEGER ? this.plusSeconds(MAX_SAFE_INTEGER) : this.plusSeconds(-secondsToSubtract));\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in milliseconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} millisToSubtract - the milliseconds to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified milliseconds subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusMillis(millisToSubtract) {\n        return (millisToSubtract === MIN_SAFE_INTEGER ? this.plusMillis(MAX_SAFE_INTEGER) : this.plusMillis(-millisToSubtract));\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in nanoseconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} nanosToSubtract - the nanoseconds to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified nanoseconds subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusNanos(nanosToSubtract) {\n        return (nanosToSubtract === MIN_SAFE_INTEGER ? this.plusNanos(MAX_SAFE_INTEGER) : this.plusNanos(-nanosToSubtract));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration multiplied by the scalar.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} multiplicand - the value to multiply the duration by, positive or negative\n     * @return {Duration} based on this duration multiplied by the specified scalar, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    multipliedBy(multiplicand) {\n        if (multiplicand === 0) {\n            return Duration.ZERO;\n        }\n        if (multiplicand === 1) {\n            return this;\n        }\n        let secs = MathUtil.safeMultiply(this._seconds, multiplicand);\n        let nos = MathUtil.safeMultiply(this._nanos, multiplicand);\n        secs = secs + MathUtil.intDiv(nos, LocalTime.NANOS_PER_SECOND);\n        nos = MathUtil.intMod(nos, LocalTime.NANOS_PER_SECOND);\n        return Duration.ofSeconds(secs, nos);\n    }\n\n    /**\n     * Returns a copy of this duration divided by the specified value.\n     *\n     * In opposite to the threeten implementation the division is realized by floating point not by\n     * fixed point arithmetic. Expect floating point rounding errors for {@link Duration.dividedBy}.\n     *\n     * @param {Number} divisor - the value to divide the duration by, positive or negative, not zero\n     * @return {Duration} based on this duration divided by the specified divisor, not null\n     * @throws ArithmeticException if the divisor is zero or if numeric overflow occurs\n     */\n    dividedBy(divisor) {\n        if (divisor === 0) {\n            throw new ArithmeticException('Cannot divide by zero');\n        }\n        if (divisor === 1) {\n            return this;\n        }\n        const secs = MathUtil.intDiv(this._seconds, divisor);\n        const secsMod = MathUtil.roundDown(((this._seconds/ divisor) - secs) * LocalTime.NANOS_PER_SECOND);\n        let nos = MathUtil.intDiv(this._nanos, divisor);\n        nos = secsMod + nos;\n        return Duration.ofSeconds(secs, nos);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration with the length negated.\n     *\n     * This method swaps the sign of the total length of this duration.\n     * For example, {@link PT1.3S} will be returned as {@link PT-1.3S}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {Duration} based on this duration with the amount negated, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    negated() {\n        return this.multipliedBy(-1);\n    }\n\n    /**\n     * Returns a copy of this duration with a positive length.\n     *\n     * This method returns a positive duration by effectively removing the sign from any negative total length.\n     * For example, {@link PT-1.3S} will be returned as {@link PT1.3S}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {Duration} based on this duration with an absolute length, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    abs() {\n        return this.isNegative() ? this.negated() : this;\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Adds this duration to the specified temporal object.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with this duration added.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#plus}.\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   dateTime = thisDuration.addTo(dateTime);\n     *   dateTime = dateTime.plus(thisDuration);\n     * </pre>\n     *\n     * The calculation will add the seconds, then nanos.\n     * Only non-zero amounts will be added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the temporal object to adjust, not null\n     * @return {Temporal} an object of the same type with the adjustment made, not null\n     * @throws DateTimeException if unable to add\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    addTo(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (this._seconds !== 0) {\n            temporal = temporal.plus(this._seconds, ChronoUnit.SECONDS);\n        }\n        if (this._nanos !== 0) {\n            temporal = temporal.plus(this._nanos, ChronoUnit.NANOS);\n        }\n        return temporal;\n    }\n\n    /**\n     * Subtracts this duration from the specified temporal object.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with this duration subtracted.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#minus}.\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   dateTime = thisDuration.subtractFrom(dateTime);\n     *   dateTime = dateTime.minus(thisDuration);\n     * </pre>\n     *\n     * The calculation will subtract the seconds, then nanos.\n     * Only non-zero amounts will be added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the temporal object to adjust, not null\n     * @return {Temporal} an object of the same type with the adjustment made, not null\n     * @throws DateTimeException if unable to subtract\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    subtractFrom(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (this._seconds !== 0) {\n            temporal = temporal.minus(this._seconds, ChronoUnit.SECONDS);\n        }\n        if (this._nanos !== 0) {\n            temporal = temporal.minus(this._nanos, ChronoUnit.NANOS);\n        }\n        return temporal;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the number of days in this duration.\n     *\n     * This returns the total number of days in the duration by dividing the\n     * number of seconds by 86400.\n     * This is based on the standard definition of a day as 24 hours.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {number} the number of days in the duration, may be negative\n     */\n    toDays() {\n        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_DAY);\n    }\n\n    /**\n     * Gets the number of hours in this duration.\n     *\n     * This returns the total number of hours in the duration by dividing the\n     * number of seconds by 3600.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {number} the number of hours in the duration, may be negative\n     */\n    toHours() {\n        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);\n    }\n\n    /**\n     * Gets the number of minutes in this duration.\n     *\n     * This returns the total number of minutes in the duration by dividing the\n     * number of seconds by 60.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {number} the number of minutes in the duration, may be negative\n     */\n    toMinutes() {\n        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_MINUTE);\n    }\n\n    /**\n     * Converts this duration to the total length in milliseconds.\n     *\n     * If this duration is too large to fit in a `long` milliseconds, then an\n     * exception is thrown.\n     *\n     * If this duration has greater than millisecond precision, then the conversion\n     * will drop any excess precision information as though the amount in nanoseconds\n     * was subject to integer division by one million.\n     *\n     * @return {number} the total length of the duration in milliseconds\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    toMillis() {\n        let millis = Math.round(MathUtil.safeMultiply(this._seconds, 1000));\n        millis = MathUtil.safeAdd(millis, MathUtil.intDiv(this._nanos, 1000000));\n        return millis;\n    }\n\n    /**\n     * Converts this duration to the total length in nanoseconds expressed as a `long`.\n     *\n     * If this duration is too large to fit in a `long` nanoseconds, then an\n     * exception is thrown.\n     *\n     * @return {number} the total length of the duration in nanoseconds\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    toNanos() {\n        let totalNanos = MathUtil.safeMultiply(this._seconds, LocalTime.NANOS_PER_SECOND);\n        totalNanos = MathUtil.safeAdd(totalNanos, this._nanos);\n        return totalNanos;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this duration to the specified {@link Duration}.\n     *\n     * The comparison is based on the total length of the durations.\n     *\n     * @param {Duration} otherDuration - the other duration to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(otherDuration) {\n        requireNonNull(otherDuration, 'otherDuration');\n        requireInstance(otherDuration, Duration, 'otherDuration');\n        const cmp = MathUtil.compareNumbers(this._seconds, otherDuration.seconds());\n        if (cmp !== 0) {\n            return cmp;\n        }\n        return this._nanos - otherDuration.nano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this duration is equal to the specified {@link Duration}.\n     *\n     * The comparison is based on the total length of the durations.\n     *\n     * @param {*} otherDuration - the other duration, null returns false\n     * @return {boolean} true if the other duration is equal to this one\n     */\n    equals(otherDuration) {\n        if (this === otherDuration) {\n            return true;\n        }\n        if (otherDuration instanceof Duration) {\n            return this.seconds() === otherDuration.seconds() &&\n                   this.nano() === otherDuration.nano();\n        }\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * A string representation of this duration using ISO-8601 seconds\n     * based representation, such as {@link PT8H6M12.345S}.\n     *\n     * The format of the returned string will be {@link PTnHnMnS}, where n is\n     * the relevant hours, minutes or seconds part of the duration.\n     * Any fractional seconds are placed after a decimal point in the seconds section.\n     * If a section has a zero value, it is omitted.\n     * The hours, minutes and seconds will all have the same sign.\n     *\n     * Examples:\n     * <pre>\n     *    \"20.345 seconds\"                 -> \"PT20.345S\n     *    \"15 minutes\" (15 * 60 seconds)   -> \"PT15M\"\n     *    \"10 hours\" (10 * 3600 seconds)   -> \"PT10H\"\n     *    \"2 days\" (2 * 86400 seconds)     -> \"PT48H\"\n     * </pre>\n     * Note that multiples of 24 hours are not output as days to avoid confusion\n     * with {@link Period}.\n     *\n     * @return {string} an ISO-8601 representation of this duration, not null\n     */\n    toString() {\n        if (this === Duration.ZERO) {\n            return 'PT0S';\n        }\n        const hours = MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);\n        const minutes = MathUtil.intDiv(MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_HOUR), LocalTime.SECONDS_PER_MINUTE);\n        const secs = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_MINUTE);\n        let rval = 'PT';\n        if (hours !== 0) {\n            rval += `${hours}H`;\n        }\n        if (minutes !== 0) {\n            rval += `${minutes}M`;\n        }\n        if (secs === 0 && this._nanos === 0 && rval.length > 2) {\n            return rval;\n        }\n        if (secs < 0 && this._nanos > 0) {\n            if (secs === -1) {\n                rval += '-0';\n            } else {\n                rval += secs + 1;\n            }\n        } else {\n            rval += secs;\n        }\n        if (this._nanos > 0) {\n            rval += '.';\n            let nanoString;\n            if (secs < 0) {\n                nanoString = `${2 * LocalTime.NANOS_PER_SECOND - this._nanos}`;\n            } else {\n                nanoString = `${LocalTime.NANOS_PER_SECOND + this._nanos}`;\n            }\n            // remove the leading '1'\n            nanoString = nanoString.slice(1, nanoString.length);\n            rval += nanoString;\n            while (rval.charAt(rval.length - 1) === '0') {\n                rval = rval.slice(0, rval.length - 1);\n            }\n        }\n        rval += 'S';\n        return rval;\n    }\n\n    /**\n     *\n     * @return {string} same as {@link Duration.toString}\n     */\n    toJSON() {\n        return this.toString();\n    }\n\n}\n\nexport function _init() {\n    /**\n     * Constant for a duration of zero.\n     */\n    Duration.ZERO = new Duration(0, 0);\n}\n","/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\n\n/**\n * attempt to avoid dependency cycles... define all constants here and they could be used\n * so instead of using e.g. Year.MAX_VALUE we could use YearConstants.MAX_VALUE to avoid the cycle\n */\nexport class YearConstants {}\n\nexport function _init() {\n    /**\n     * The minimum supported year\n     */\n    YearConstants.MIN_VALUE = -999999;\n    /**\n     * The maximum supported year\n     */\n    YearConstants.MAX_VALUE = 999999;\n}\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { MathUtil } from '../MathUtil';\n\nimport { Duration } from '../Duration';\nimport { YearConstants } from '../YearConstants';\nimport { TemporalUnit } from './TemporalUnit';\n\n/**\n * A standard set of date periods units.\n *\n * This set of units provide unit-based access to manipulate a date, time or date-time.\n * The standard set of units can be extended by implementing {@link TemporalUnit}.\n *\n * These units are intended to be applicable in multiple calendar systems.\n * For example, most non-ISO calendar systems define units of years, months and days,\n * just with slightly different rules.\n * The documentation of each unit explains how it operates.\n *\n * ### Static properties:\n * \n * - `ChronoUnit.CENTURIES`: Unit that represents the concept of a century. For the ISO calendar\n * system, it is equal to 100 years.\n * \n * - `ChronoUnit.DAYS`: Unit that represents the concept of a day. For the ISO calendar system, it\n * is the standard day from midnight to midnight. The estimated duration of a day is 24 Hours.\n * \n * - `ChronoUnit.DECADES`: Unit that represents the concept of a decade. For the ISO calendar system,\n * it is equal to 10 years.\n * \n * - `ChronoUnit.ERAS`: Unit that represents the concept of an era. The ISO calendar system doesn't\n * have eras thus it is impossible to add an era to a date or date-time. The estimated duration of the\n * era is artificially defined as 1,000,000,000 Years.\n * \n * - `ChronoUnit.FOREVER`: Artificial unit that represents the concept of forever. This is primarily\n * used with {@link TemporalField} to represent unbounded fields such as the year or era. The\n * estimated duration of the era is artificially defined as the largest duration supported by\n * {@link Duration}.\n * \n * - `ChronoUnit.HALF_DAYS`: Unit that represents the concept of half a day, as used in AM/PM. For\n * the ISO calendar system, it is equal to 12 hours.\n *\n * - `ChronoUnit.HOURS`: Unit that represents the concept of an hour. For the ISO calendar system,\n * it is equal to 60 minutes.\n * \n * - `ChronoUnit.MICROS`: Unit that represents the concept of a microsecond. For the ISO calendar\n * system, it is equal to the 1,000,000th part of the second unit.\n * \n * - `ChronoUnit.MILLENNIA`: Unit that represents the concept of a millennium. For the ISO calendar\n * system, it is equal to 1,000 years.\n * \n * - `ChronoUnit.MILLIS`: Unit that represents the concept of a millisecond. For the ISO calendar\n * system, it is equal to the 1000th part of the second unit.\n * \n * - `ChronoUnit.MINUTES`: Unit that represents the concept of a minute. For the ISO calendar system,\n * it is equal to 60 seconds.\n * \n * - `ChronoUnit.MONTHS`: Unit that represents the concept of a month. For the ISO calendar system,\n * the length of the month varies by month-of-year. The estimated duration of a month is one twelfth\n * of 365.2425 Days.\n * \n * - `ChronoUnit.NANOS`: Unit that represents the concept of a nanosecond, the smallest supported unit\n * of time. For the ISO calendar system, it is equal to the 1,000,000,000th part of the second unit.\n * \n * - `ChronoUnit.SECONDS`: Unit that represents the concept of a second. For the ISO calendar system,\n * it is equal to the second in the SI system of units, except around a leap-second.\n * \n * - `ChronoUnit.WEEKS`: Unit that represents the concept of a week. For the ISO calendar system,\n * it is equal to 7 Days.\n * \n * - `ChronoUnit.YEARS`: Unit that represents the concept of a year. For the ISO calendar system, it\n * is equal to 12 months. The estimated duration of a year is 365.2425 Days.\n */\nexport class ChronoUnit extends TemporalUnit {\n\n    /**\n     *\n     * @param {String} name\n     * @param {Duration} estimatedDuration\n     * @private\n     */\n    constructor (name, estimatedDuration) {\n        super();\n        this._name = name;\n        this._duration = estimatedDuration;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * @return {Duration} the duration of this unit, which may be an estimate.\n     */\n    duration() {\n        return this._duration;\n    }\n\n    /**\n     * @return {boolean} `true` if the duration is estimated, `false` if accurate.\n     */\n    isDurationEstimated() {\n        return this.isDateBased() || this === ChronoUnit.FOREVER;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * @return {boolean} `true` if date unit, `false` if a time unit.\n     */\n    isDateBased() {\n        return this.compareTo(ChronoUnit.DAYS) >= 0 && this !== ChronoUnit.FOREVER;\n    }\n\n    /**\n     * Checks if this unit is a time unit.\n     *\n     * @return {boolean} `true` if time unit, `false` if a date unit.\n     */\n    isTimeBased() {\n        return this.compareTo(ChronoUnit.DAYS) < 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * @param {!Temporal} temporal the temporal object to check.\n     * @return {boolean} `true` if the unit is supported.\n     */\n    isSupportedBy(temporal) {\n        if (this === ChronoUnit.FOREVER) {\n            return false;\n        }\n        /* TODO: classes not implemented yet */\n        /*\n        if (temporal instanceof ChronoLocalDate) {\n            return isDateBased();\n        }\n        if (temporal instanceof ChronoLocalDateTime || temporal instanceof ChronoZonedDateTime) {\n            return true;\n        }\n*/\n        try {\n            temporal.plus(1, this);\n            return true;\n        } catch (e) {\n            try {\n                temporal.plus(-1, this);\n                return true;\n            } catch (e2) {\n                return false;\n            }\n        }\n    }\n\n    /**\n     * @param {!Temporal} temporal the temporal object to adjust.\n     * @param {number} amount the period of this unit to add, positive or negative.\n     * @return {Temporal} the adjusted temporal object.\n     * @throws DateTimeException if the period cannot be added.\n     */\n    addTo(temporal, amount) {\n        return temporal.plus(amount, this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * @param {!Temporal} temporal1 the base temporal object.\n     * @param {!Temporal} temporal2 the other temporal object.\n     * @return {number} the period between temporal1 and temporal2 in terms of this unit;\n     *  positive if temporal2 is later than temporal1, negative if earlier.\n     * @throws DateTimeException if the period cannot be calculated.\n     * @throws ArithmeticException if numeric overflow occurs.\n     */\n    between(temporal1, temporal2) {\n        return temporal1.until(temporal2, this);\n    }\n\n    //-----------------------------------------------------------------------\n    toString() {\n        return this._name;\n    }\n\n    /**\n     * Compares this ChronoUnit to the specified {@link TemporalUnit}.\n     *\n     * The comparison is based on the total length of the durations.\n     *\n     * @param {!TemporalUnit} other the other unit to compare to.\n     * @return the comparator value, negative if less, positive if greater.\n     */\n    compareTo(other) {\n        return this.duration().compareTo(other.duration());\n    }\n\n}\n\nexport function _init() {\n    /**\n     * Unit that represents the concept of a nanosecond, the smallest supported unit of time.\n     * For the ISO calendar system, it is equal to the 1,000,000,000th part of the second unit.\n     */\n    ChronoUnit.NANOS = new ChronoUnit('Nanos', Duration.ofNanos(1));\n    /**\n     * Unit that represents the concept of a microsecond.\n     * For the ISO calendar system, it is equal to the 1,000,000th part of the second unit.\n     */\n    ChronoUnit.MICROS = new ChronoUnit('Micros', Duration.ofNanos(1000));\n    /**\n     * Unit that represents the concept of a millisecond.\n     * For the ISO calendar system, it is equal to the 1000th part of the second unit.\n     */\n    ChronoUnit.MILLIS = new ChronoUnit('Millis', Duration.ofNanos(1000000));\n    /**\n     * Unit that represents the concept of a second.\n     * For the ISO calendar system, it is equal to the second in the SI system\n     * of units, except around a leap-second.\n     */\n    ChronoUnit.SECONDS = new ChronoUnit('Seconds', Duration.ofSeconds(1));\n    /**\n     * Unit that represents the concept of a minute.\n     * For the ISO calendar system, it is equal to 60 seconds.\n     */\n    ChronoUnit.MINUTES = new ChronoUnit('Minutes', Duration.ofSeconds(60));\n    /**\n     * Unit that represents the concept of an hour.\n     * For the ISO calendar system, it is equal to 60 minutes.\n     */\n    ChronoUnit.HOURS = new ChronoUnit('Hours', Duration.ofSeconds(3600));\n    /**\n     * Unit that represents the concept of half a day, as used in AM/PM.\n     * For the ISO calendar system, it is equal to 12 hours.\n     */\n    ChronoUnit.HALF_DAYS = new ChronoUnit('HalfDays', Duration.ofSeconds(43200));\n    /**\n     * Unit that represents the concept of a day.\n     * For the ISO calendar system, it is the standard day from midnight to midnight.\n     * The estimated duration of a day is 24 hours.\n     *\n     * When used with other calendar systems it must correspond to the day defined by\n     * the rising and setting of the Sun on Earth. It is not required that days begin\n     * at midnight - when converting between calendar systems, the date should be\n     * equivalent at midday.\n     */\n    ChronoUnit.DAYS = new ChronoUnit('Days', Duration.ofSeconds(86400));\n    /**\n     * Unit that represents the concept of a week.\n     * For the ISO calendar system, it is equal to 7 days.\n     *\n     * When used with other calendar systems it must correspond to an integral number of days.\n     */\n    ChronoUnit.WEEKS = new ChronoUnit('Weeks', Duration.ofSeconds(7 * 86400));\n    /**\n     * Unit that represents the concept of a month.\n     * For the ISO calendar system, the length of the month varies by month-of-year.\n     * The estimated duration of a month is one twelfth of 365.2425 days.\n     *\n     * When used with other calendar systems it must correspond to an integral number of days.\n     */\n    ChronoUnit.MONTHS = new ChronoUnit('Months', Duration.ofSeconds(31556952 / 12));\n    /**\n     * Unit that represents the concept of a year.\n     * For the ISO calendar system, it is equal to 12 months.\n     * The estimated duration of a year is 365.2425 days.\n     *\n     * When used with other calendar systems it must correspond to an integral number of days\n     * or months roughly equal to a year defined by the passage of the Earth around the Sun.\n     */\n    ChronoUnit.YEARS = new ChronoUnit('Years', Duration.ofSeconds(31556952));\n    /**\n     * Unit that represents the concept of a decade.\n     * For the ISO calendar system, it is equal to 10 years.\n     *\n     * When used with other calendar systems it must correspond to an integral number of days\n     * and is normally an integral number of years.\n     */\n    ChronoUnit.DECADES = new ChronoUnit('Decades', Duration.ofSeconds(31556952 * 10));\n    /**\n     * Unit that represents the concept of a century.\n     * For the ISO calendar system, it is equal to 100 years.\n     *\n     * When used with other calendar systems it must correspond to an integral number of days\n     * and is normally an integral number of years.\n     */\n    ChronoUnit.CENTURIES = new ChronoUnit('Centuries', Duration.ofSeconds(31556952 * 100));\n    /**\n     * Unit that represents the concept of a millennium.\n     * For the ISO calendar system, it is equal to 1000 years.\n     *\n     * When used with other calendar systems it must correspond to an integral number of days\n     * and is normally an integral number of years.\n     */\n    ChronoUnit.MILLENNIA = new ChronoUnit('Millennia', Duration.ofSeconds(31556952 * 1000));\n    /**\n     * Unit that represents the concept of an era.\n     * The ISO calendar system doesn't have eras thus it is impossible to add\n     * an era to a date or date-time.\n     * The estimated duration of the era is artificially defined as {Year.MAX_VALUE} + 1.\n     *\n     * When used with other calendar systems there are no restrictions on the unit.\n     */\n    ChronoUnit.ERAS = new ChronoUnit('Eras', Duration.ofSeconds(31556952 * (YearConstants.MAX_VALUE + 1)));\n    /**\n     * Artificial unit that represents the concept of forever.\n     * This is primarily used with {@link TemporalField} to represent unbounded fields\n     * such as the year or era.\n     * The estimated duration of the era is artificially defined as the largest duration\n     * supported by {@link Duration}.\n     */\n    ChronoUnit.FOREVER = new ChronoUnit('Forever', Duration.ofSeconds(MathUtil.MAX_SAFE_INTEGER, 999999999));\n}\n","import { abstractMethodFail } from '../assert';\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\n/**\n * A field of date-time, such as month-of-year or hour-of-minute.\n *\n * Date and time is expressed using fields which partition the time-line into something\n * meaningful for humans. Implementations of this interface represent those fields.\n *\n * The most commonly used units are defined in {@link ChronoField}.\n * Further fields are supplied in {@link IsoFields}, {@link WeekFields} and {@link JulianFields}.\n * Fields can also be written by application code by implementing this interface.\n *\n * The field works using double dispatch. Client code calls methods on a date-time like\n * {@link LocalDateTime} which check if the field is a {@link ChronoField}.\n * If it is, then the date-time must handle it.\n * Otherwise, the method call is re-dispatched to the matching method in this interface.\n *\n * @interface\n */\nexport class TemporalField {\n    /**\n     * Checks if this field represents a component of a date.\n     *\n     * @return {boolean} `true` if it is a component of a date, `false` otherwise.\n     */\n    isDateBased() {\n        abstractMethodFail('isDateBased');\n    }\n\n    /**\n     * Checks if this field represents a component of a time.\n     *\n     * @return {boolean} `true` if it is a component of a time, `false` otherwise.\n     */\n    isTimeBased() {\n        abstractMethodFail('isTimeBased');\n    }\n\n    /**\n     * Gets the unit that the field is measured in.\n     *\n     * The unit of the field is the period that varies within the range.\n     * For example, in the field 'MonthOfYear', the unit is 'Months'.\n     * See also {@link rangeUnit}.\n     *\n     * @return {TemporalUnit} the period unit defining the base unit of the field.\n     */\n    baseUnit() {\n        abstractMethodFail('baseUnit');\n    }\n\n    /**\n     * Gets the range that the field is bound by.\n     * \n     * The range of the field is the period that the field varies within.\n     * For example, in the field 'MonthOfYear', the range is 'Years'.\n     * See also {@link baseUnit}.\n     * \n     * The range is never null. For example, the 'Year' field is shorthand for\n     * 'YearOfForever'. It therefore has a unit of 'Years' and a range of 'Forever'.\n     *\n     * @return {TemporalUnit} the period unit defining the range of the field.\n     */\n    rangeUnit() {\n        abstractMethodFail('rangeUnit');\n    }\n\n    /**\n     * Gets the range of valid values for the field.\n     *\n     * All fields can be expressed as an integer.\n     * This method returns an object that describes the valid range for that value.\n     * This method is generally only applicable to the ISO-8601 calendar system.\n     *\n     * Note that the result only describes the minimum and maximum valid values\n     * and it is important not to read too much into them. For example, there\n     * could be values within the range that are invalid for the field.\n     *\n     * @return {ValueRange} the range of valid values for the field.\n     */\n    range() {\n        abstractMethodFail('range');\n    }\n\n    /**\n     * Get the range of valid values for this field using the temporal object to\n     * refine the result.\n     *\n     * This uses the temporal object to find the range of valid values for the field.\n     * This is similar to {@link range}, however this method refines the result\n     * using the temporal. For example, if the field is {@link DAY_OF_MONTH} the\n     * {@link range} method is not accurate as there are four possible month lengths,\n     * 28, 29, 30 and 31 days. Using this method with a date allows the range to be\n     * accurate, returning just one of those four options.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link TemporalAccessor#range}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisField.rangeRefinedBy(temporal);\n     *   temporal = temporal.range(thisField);\n     * </pre>\n     * It is recommended to use the second approach, {@link range},\n     * as it is a lot clearer to read in code.\n     *\n     * Implementations should perform any queries or calculations using the fields\n     * available in {@link ChronoField}.\n     * If the field is not supported a {@link DateTimeException} must be thrown.\n     *\n     * @param {!TemporalAccessor} temporal the temporal object used to refine the result.\n     * @return {ValueRange} the range of valid values for this field.\n     * @throws {DateTimeException} if the range for the field cannot be obtained.\n     * \n     */\n    // eslint-disable-next-line no-unused-vars\n    rangeRefinedBy(temporal) {\n        abstractMethodFail('rangeRefinedBy');\n    }\n\n    /**\n     * Gets the value of this field from the specified temporal object.\n     *\n     * This queries the temporal object for the value of this field.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link TemporalAccessor#get}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisField.getFrom(temporal);\n     *   temporal = temporal.get(thisField);\n     * </pre>\n     * It is recommended to use the second approach, as it is a lot clearer to read in code.\n     *\n     * Implementations should perform any queries or calculations using the fields\n     * available in {@link ChronoField}.\n     * If the field is not supported a {@link DateTimeException} must be thrown.\n     *\n     * @param {!TemporalAccesor} temporal the temporal object to query.\n     * @return {number} the value of this field.\n     * @throws {DateTimeException} if a value for the field cannot be obtained.\n     */\n    // eslint-disable-next-line no-unused-vars\n    getFrom(temporal) {\n        abstractMethodFail('getFrom');\n    }\n\n    /**\n     * Returns a copy of the specified temporal object with the value of this field set.\n     *\n     * This returns a new temporal object based on the specified one with the value for\n     * this field changed. For example, on a {@link LocalDate}, this could be used to\n     * set the year, month or day-of-month.\n     * The returned object has the same observable type as the specified object.\n     *\n     * In some cases, changing a field is not fully defined. For example, if the target object is\n     * a date representing the 31st January, then changing the month to February would be unclear.\n     * In cases like this, the implementation is responsible for resolving the result.\n     * Typically it will choose the previous valid date, which would be the last valid\n     * day of February in this example.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisField.adjustInto(temporal);\n     *   temporal = temporal.with(thisField);\n     * </pre>\n     * It is recommended to use the second approach, `with(temporal)`,\n     * as it is a lot clearer to read in code.\n     *\n     * Implementations should perform any queries or calculations using the fields\n     * available in {@link ChronoField}.\n     * If the field is not supported a {@link DateTimeException} must be thrown.\n     *\n     * Implementations must not alter the specified temporal object.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable implementations.\n     *\n     * @param {!Temporal} temporal the temporal object to adjust.\n     * @param {!number} newValue the new value of the field.\n     * @return {Temporal} the adjusted temporal object.\n     * @throws {DateTimeException} if the field cannot be set.\n     */\n    // eslint-disable-next-line no-unused-vars\n    adjustInto(temporal, newValue) {\n        abstractMethodFail('adjustInto');\n    }\n\n    /**\n     * Checks if this field is supported by the temporal object.\n     *\n     * This determines whether the temporal accessor supports this field.\n     * If this returns false, the the temporal cannot be queried for this field.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link TemporalAccessor#isSupported}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisField.isSupportedBy(temporal);\n     *   temporal = temporal.isSupported(thisField);\n     * </pre>\n     * It is recommended to use the second approach, `isSupported(temporal)`,\n     * as it is a lot clearer to read in code.\n     *\n     * Implementations should determine whether they are supported using the fields\n     * available in {@link ChronoField}.\n     *\n     * @param {!TemporalAccesor} temporal the temporal object to query.\n     * @return {boolean} `true` if the date-time can be queried for this field, `false` if not.\n     */\n    // eslint-disable-next-line no-unused-vars\n    isSupportedBy(temporal) {\n        abstractMethodFail('isSupportedBy');\n    }\n\n    /**\n     * @return {string}\n     */\n    displayName(/* TODO: locale */) {\n        abstractMethodFail('displayName');\n    }\n\n    /**\n    * @param {*} other\n    * @returns {boolean}\n    */\n    // eslint-disable-next-line no-unused-vars\n    equals(other) {\n        abstractMethodFail('equals');\n    }\n\n    /**\n     * @returns {string}\n     */\n    name() {\n        abstractMethodFail('name');\n    }\n}\n","/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { assert } from '../assert';\nimport { DateTimeException, IllegalArgumentException } from '../errors';\nimport { MathUtil } from '../MathUtil';\n\n/**\n * The range of valid values for a date-time field.\n *\n * All TemporalField instances have a valid range of values.\n * For example, the ISO day-of-month runs from 1 to somewhere between 28 and 31.\n * This class captures that valid range.\n *\n * It is important to be aware of the limitations of this class.\n * Only the minimum and maximum values are provided.\n * It is possible for there to be invalid values within the outer range.\n * For example, a weird field may have valid values of 1, 2, 4, 6, 7, thus\n * have a range of '1 - 7', despite that fact that values 3 and 5 are invalid.\n *\n * Instances of this class are not tied to a specific field.\n */\nexport class ValueRange {\n\n    /**\n     *\n     * @param {!number} minSmallest\n     * @param {!number} minLargest\n     * @param {!number} maxSmallest\n     * @param {!number} maxLargest\n     * @private\n     */\n    constructor(minSmallest, minLargest, maxSmallest, maxLargest) {\n        assert(!(minSmallest > minLargest), `Smallest minimum value '${minSmallest \n        }' must be less than largest minimum value '${minLargest}'`, IllegalArgumentException);\n        assert(!(maxSmallest > maxLargest), `Smallest maximum value '${maxSmallest \n        }' must be less than largest maximum value '${maxLargest}'`, IllegalArgumentException);\n        assert(!(minLargest > maxLargest), `Minimum value '${minLargest \n        }' must be less than maximum value '${maxLargest}'`, IllegalArgumentException);\n\n        this._minSmallest = minSmallest;\n        this._minLargest = minLargest;\n        this._maxLargest = maxLargest;\n        this._maxSmallest = maxSmallest;\n    }\n\n    /**\n     * Is the value range fixed and fully known.\n     *\n     * For example, the ISO day-of-month runs from 1 to between 28 and 31.\n     * Since there is uncertainty about the maximum value, the range is not fixed.\n     * However, for the month of January, the range is always 1 to 31, thus it is fixed.\n     *\n     * @return {boolean} true if the set of values is fixed\n     */\n    isFixed() {\n        return this._minSmallest === this._minLargest && this._maxSmallest === this._maxLargest;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    minimum(){\n        return this._minSmallest;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    largestMinimum(){\n        return this._minLargest;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    maximum(){\n        return this._maxLargest;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    smallestMaximum(){\n        return this._maxSmallest;\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    isValidValue(value) {\n        return (this.minimum() <= value && value <= this.maximum());\n    }\n\n    /**\